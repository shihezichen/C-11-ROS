### C++11基本知识点

1. 快速初始化类成员变量:

   ```c++
   // 快速初始化: 在声明时使用=初始化
   // C++98: 仅仅支持类的整型/枚举型的静态成员常量
   // C++11: 支持类的静态/非静态成员常量/变量
   
   // 代码片段: 类内部成员变量
   struct Mem {
       int num = 2;  // =初始化
       const char * ptrPath = "/root";   // =初始化
       string  path("/home");     	// ()初始化
       ClassA  objA(5);        	// ()初始化
       double  percent {1.2}   	// {}进行变量初始化
       
       // 初始化列表 ( 优先级高于直接初始化 )
       Mem(int i)  : num(i), path("/var") {}
   }	
   ```
   
2. {} 进行变量初始化

   ```c++
   // 代码片段
   
   #include <vector>
   #include <map>
   
   struct Student {
       char * name ;
       int age;
   }
   
   
   // C++98: {} 对POD(Plain of Data)初始化
   Student one = { "Tom&Jerry",  18};   
   // C++98: {} 对POD数组进行初始化
   Student students[] = { {"Tom", 18 }, {"Jerry",  18}  };
   // C++11: {} 直接初始化
   Student two{ "Tom&Jerry",  18 };
   // C++11: 相当于 new Student("Tom",18)
   Student *pStudent = new Student{ "Tom", 18 }; 
   double * d = new double{1.2f}
   
   // C++11: 多维数组
   int * pNum = new int[3]{1,2,0};
   int a[] = {1, 3, 5};
   
   // 容器
   vector<int> c{1, 3, 5};
   vector<string>  vs = {"one", "two", "three"};
   map<string,string> singers = { {"Lady Gaga", "US"}, { "Beyonce Knowles", "US"} };
   // 简单变量
   int a = { 0 };
   ```
   
3. final关键字, override关键字

   ```c++
   // 使用 final 把方法声明为不可以被重载
   // 使用 override , 表示重载父类的同名虚函数
    
   
   // 接口
   struct InterfaceA{
       virtual void fun() = 0;
   };
   // 实现类(基类)
   struct Base: public Object {
       // 声明为 final, 其子类将无法重载 fun 函数
       void fun() final;  
       void print();
       virtual void turning()  = 0;
       virtual void dijkstra(int g) = 0;
   };
   // 实现类(子类)
   struct Derive: public Base {
       void turrrring() override;     // 无法通过编译, 拼写错误, 并非重载
       void print() override;         // 无法通过编译, 非虚函数重载
       virtual void dijkstra(double g) = 0;  // 无法通过编译, 参数不一致, 并非重载
   }
   ```
   
4. 默认函数参数, 默认模板参数

   ```c++
   // 默认函数参数
   void defParam( int m = 3 ) {} 
   
   // 类模板的默认模板参数
   // 注意: 有多个模板参数时, 默认模板参数需要在右边
   template <typename T = int> 
   class DefClass {};
   
   // C++11: 函数模板的默认模板参数
   template <typename T = int>
   void defTempParam() {};
   
   ```

5. 模板显式实例化,  外部模板

   ```c++
   // 模板显式实例化(Explicit Instantiation),
   //  减少编译器/链接器实例化展开以及去除冗余时的耗时(大型工程较明显)
   
   // 示例代码:  test.h
   template <typename T> void fun(T)  {}
   
   // test.cpp
   #include "test.h"
   // 显式实例化 fun
   template void fun<int>(int);  
   
   // test2.cpp
   #include "test.h"
   // 外部模板声明
   extern template void fun<int>(int);
   // 使用
   void test() { fun(5); }
   ```

6. 局部类型作为模板实参

   ```c++
   // C++11 支持用局部类型作为模板类的实参
   
   // 模板类
   template <typename T>  class X { T data };
   
   void fun() {
       // ClassA是局部类型
       struct ClassA { int a=10; } c;  
       // 使用局部类型作为模板参数 实例化  x1
       X<C>  x1;    
   }
   ```

7. using 关键字:  子类继承父类的构造函数 

   ```c++
   // 当父类有很多构造函数时, 子类不需要也写这么多构造函数, 可以直接继承, 减少代码冗余
   
   // 父类有很多构造函数
   struct A {
       A(int i) {}
       A(double d, int i) {}
       A(float f, int i, const char* c) {}
       
       // 成员函数
       void f(double d) {}
       void f(long long ll) {}
   }
   
   // 子类
   struct B: A {
       // 继承构造函数
       using A::A;  
       
       // 继承父类的 f 函数
       using A::f;
       // 新增的 f 函数
       void f( const char* c ) {}
   }
   ```

8. 委派构造函数: delegating constructor

   ```c++
   // 当构造函数中存在大量重复代码时,可以提取成为一个公共构造函数,
   // 作为委派构造函数, 供其他委派构造函数调用
   
   class Info {
   public:
       // 调用委派构造函数
       Info(int i) : Info()  {  }
       // 调用委派构造函数
       Info(char e) : Info() {  }
       
   private:    
       // 公共的构造函数, 作为 委派构造函数
       Info() {  /* 其他初始化*/ }    
       //...
   }
   ```

9. 带有指针成员的拷贝构造

   ```c++
   // 当类成员有指针成员变量时, 通过一个对象初始化另一个对象时, 
   // 如果没有声明拷贝构造函数, 就只会进行指针的浅拷贝(shollow copy), 
   // 两个对象的指针指向了同一个地址, 一个对象释放时会导致另一个对象的指针变为悬挂指针.
   // 因此需要自定义拷贝构造函数实现(deep copy)
   
   // 含有指针的类
   class HasPrtMem {
   public:     
       HasPtrMem() : d(new int(0)) { }
       // 拷贝构造函数, 从heap中分配内存, 并使用*ptr.d进行初始化
       HasPtrMem( HasPtrMem &ptr): d( new int(*ptr.d) ) { }
       ~HasPtrMem() { delete d; }
       int *d;
   }
   
   int main() {
       HasPtrMem  a;
       // 使用a初始化b, 引发拷贝构造函数
       HasPtrMem b(a);
   }
   ```

10. 左值、右值、右值引用

    ```c++
    // 判别法1: 在赋值表达式中, 等号左边的是"左值", 右边的是"右值"
    //  a = b + c
    
    // 判别法: 可以取地址的/有名字的就是左值,  反之,不能取地址/没有名字的就是右值
    
    // 由于右值不具有名字,因此只能通过引用的方式找到它;
    // 一般情况下,也只能从右值表达式获得右值引用
    // T && a = ReturnRValue();   
    // 假设ReturnRValue()返回一个右值, 
    //  a则为右值引用,其值等于函数返回的临时变量的值, 这个临时变量生命周期和a将一样
    
    // 区别: T && a = ReturnRValue();    (1)
    //       T    b = ReturnRValue();    (2)
    //  (1)相比(2), 少一次析构和构造, 因为a是右值引用,直接绑定函数返回的临时变量
    //  b只是由临时变量构造而成, 临时变量会析构.
    
    
    // void AcceptVal( ClassA ) {}                    (1)
    // void AccpptVal( const ClassA & ) {}            (2)
    // 调用(1)是临时值被拷贝传入, 引发ClassA的拷贝构造
    // 调用(2)是临时值被作为引用传递, 不会引发ClassA的拷贝构造
    
    // C++规定: 声明一个引用, 都必须立即进行初始化
    
    ```

11. std::move : 把左值强制转化为右值引用

    ```c++
    // std::move 基本等同于一个类型转换, 转化之后, 可师兄右值引用使用该值
    // 注: 被转化的左值, 生命周期并不发生变化, 不会被立即析构
    
    // 更多时候, 需要转化为右值引用的, 是一个生命周期即将结束的对象,例如:
    
    #include <iostream>
    using namespace std;
    
    // 含有指针和移动构造函数的类
    class HugeMem {
        int *c;
        int sz;
    public:
        HugeMem(int size): sz( size > 0 ? size : 1 ) { 
            c = new int[sz];
        }
        ~HugeMem() { delete [] c; }
        // 移动构造函数
        HugeMem(HugeMem && hm) : sz(hm.sz), c(hm.c) {
            hm.c = nullptr;
        }
    }
    
    // 含有HugeMem的类
    class Moveable {
        int * i;
        HugeMem h;
        Moveable() : i(new int(3)), h(1024) {}
        ~Moveable() { delete i; }
        Moveable( Moveable &&m ) :
        	i(m.i), h( move(m.h) ) {   // 强制转为右值,以调用移动构造函数
            	m.i = nullptr;   // 移动之后, 原始指针置空
        }  
    }
    
    // 获得一个临时对象
    Moveable getTemp() {
        Moveable tmp = Moveable();
        cout << hex << "addr: " << __func__ 
            << " @" << tmp.h.c << endl;  // addr: GetTemp @0x603030
        return tmp;
    }
    
    int main() {
        Moveable a( getTemp() );
        cout << hex << "addr: " << __func__
            << " @" << a.h.c << endl;   // addr: main @0x603030    
    }
    
    // Moveable 包含 HugeMem
    // Moveable 移动构造函数中, 使用了 std::move 把m.h强制转化为右值, 以便于迫使m.h能够调用移动构造, m这个变量在表达式结束后被析构, 所以其m.h置为nullptr也不会有问题.
    // 如果不使用 std::move , 则会调用m的拷贝构造函数
    
    ```

12. 自定义类型使用列表初始化

    ```c++
    // 已知 STL 中的容器类可以使用初始化列表:
    //   vector<int> c{1,3, 5};
    // 以上能力得益于<intializer_list>头文件中initialize_list类模板的支持
    // 只要包含了<initializer_list>头文件, 并且声明一个以initialze_list<T>模板类为参数的构造函数, 就可以使得自定义的类使用列表初始化
    
    #include <vector>
    #include <string>
    #include <initializer_list>
    using namespace std;
    
    enmum Gender {boy, girl};
    class People {
        vector<pair<string, Gender>> data;
    public:    
        // initializer_list的构造函数
        People( initializer_list<pair<string, Gender>> ll ) {
            auto i = ll.begin();
            for(; i != ll.end; ++i) {
                data.push_back(*i);
            }
        }
    }
    
    // 使用
    People ship = {{"Garfield", boy}, { "HelloKitty", girl}  };
    
    ```

13. 函数参数列表使用初始化列表

    ```c++
    // 同上, 函数参数列表也可以初始化列表
    
    #include <initializer_list>
    using namespace std;
    
    void Fun(initializer_list<int> iv) { }
    
    int main() {
        Fun({1, 3});
        Fun({});  // 空列表
    }
    ```

14. auto 的使用:

    ```c++
    // iterator
    void loopvoer(std::vector<std::string> &vs ){
        for( auto  it = vs.begin; it < vs.end(); it++) {
            // do something
        }
    }
    
    // 模板定义中
    template<typename T1, typename T2>
    auto Sum(T1 & t1, T2 & t2) {
        // s的类型会在模板实例化时被推导出来
        auto s = t1 + t2;
        return s;
    }
    auto e = Sum<int, log<(3, 5); // s 为 long
    auto f = Sum<float, float>(10.0f, 2.3f);  // s 为 float
    ```

15.  for 循环

    ```c++
    // 使用指针遍历数组
    
    #include <algorithm>
    #include <iostream>
    using namespace std;
    
    int action1(int &e) { e *= 2; }
    int action2(int &e) { e -= 3; }
    
    int main() {
        int arr[5] = { 1, 3, 5, 7, 9 };
        // 使用STL的for_each模板函数进行for循环遍历
        for_each(arr, arr+sizeof(arr)/sizeof(arr[0]), action1);
        for_each(arr, arr+sizeof(arr)/sizeof(arr[0]), action2); 
    }
    
    
    // C++11: 基于范围的for循环遍历
    //  前提条件1:  for循环迭代的范围可确定, 即end()和begin()之间范围,或数组的第一个和最后一个元素之间范围(意味着需要已知数组长度)
    //  前提条件2:  迭代对象要实现++和==操作符
    #include <iostream>
    using namespace std;
    
    int main() {
        int arr[5] = { 1, 2, 3, 4, 5 };
        // 若循环过程改变迭代变量的值, 使用引用的方式 &
        for( auto & e: arr ) {  
            e *= 2;   // e是迭代对象的引用
        }
        // 若循环过程中不改变迭代变量的值, 不使用引用方式
        for( auto e: arr ) {
            cout << e << endl;  // e是迭代对象解引用后的对象
        }
        // C++98 迭代器写法
        vector<int> v = { 1, 3, 5, 7, 9 };
        for( auto it = v.begin(); it != v.end(); ++it ) {
            cout << *it << endl;   // it 是迭代对象
        }
    }
    
    // 如下代码编译时会出错, 因为数组arr的范围是入参,不是确定的
    int func(int arr[]) {
        for( auto e: arr) {
            //
        }
    }
    ```

16. enum class:  枚举类/强类型枚举(strong-typed enum)

    ```c++
    // 强作用域: 强类型枚举成员名称不会被输出到其父作用域空间( C++98中, 多个不同namespace中的enum名称/enum的成员名字全局可见, 可以不加namespace::就访问到)
    // 转换限制: 强类型枚举成员的值不可以与整型隐式地相互转换( C++98中会隐式转换)
    // 可以指定底层类型: 默认是int, 但是也可以显式指定底层类型
    
    #include <iostream>
    using namespace std;
    
    enum class Type { General, Light, Medium , Heavy };
    // 显式赋值
    enum class Category { General = 1, Pistol, MahineGun, Cannon };
    // 基于 char 类型
    enum class C: char { C1=1, C2=2 };
    
    int main() {
        Type t = Type::Light;
        t = General;     // 编译失败
        if( t == Category::General ) {  // 编译失败, 必须使用Type类型
            // do something
        }
        if( t > 0 ) {   // 编译失败, 无法隐式转换为 int 类型
            // do something
        }
        if( (int) t > 0 ) {  //通过编译
            // do something
        }
        // 可判断是否是pod( plain old data structure)
        cout << is_pod<Type>::value << endl;   // 1
    }
    
    ```

17. C++的智能指针:

    ```c++
    // 智能指针是模板类, 创建时需要指定类型表明指针所指向的类型
    // 智能指针本质上时重载了 -> 和 * 操作符的类, 实现对内存的管理,通过析构函数完成内存释放;
    
    ```

    

18. C++11的智能指针: unique_ptr

    ```c++
    // unique_ptr: 无法复制, 不能与其他unique_ptr类型指针对象共享所指对象的内存
    // 实现上: 它是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型
    //  仅可以使用右值对unique_ptr对象进行构造,一旦成功过, 它的指针即被转移, 失去对指针的"所有权"
    
    #include <memory>
    #include <iostream>
    using namespac std;
    
    int main() {
        // 智能指针是模板类, 因此需要指定类型
        unique_ptr<int> up1( new int(11) );  
        unique_ptr<int> up2 = up1;  // 不能通过编译
        // 现在p3是数据唯一的unique_ptr智能指针, 再访问*up1会导致运行时错误
        unique_ptr<int> up3 = move(up1);  
        cout  << *up3 << endl;
        up3.reset();     // 显式释放
        up1.reset();     // 不会导致运行时错误
    }
    ```

19. C++11的智能指针: shared_ptr

    ```c++
    // shared_ptr: 允许多个这种指针共享地拥有同一堆分配对象的内存.
    // 实现上: 采用应用技术, 一个shared_ptr失效, 不会影响其他shared_ptr对对象内存的引用\
    智能
    
    #include <memeory>
    #include <iostream>
    using namespace std;
    
    int main() {
        shared_ptr<int> sp1( new int(22) );
        shared_ptr<int> sp2 = sp1;
        
        cout << *sp1 << endl;   // 22
        cout << *sp2 << endl;   // 22
        
        sp1.reset();
        cout << *sp2 << endl;  //22
    }
    ```

    

20. 

21. 

    

